!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
!
!  Differentiation of surface_drag in reverse (adjoint) mode (with options r8):
!   gradient     of useful results: v_phy rublten z rvblten u_phy
!   with respect to varying inputs: v_phy rublten z rvblten u_phy
!-------------------------------------------------------------------
!WRF:MODEL_LAYER:PHYSICS
MODULE a_module_bl_surface_drag
CONTAINS
SUBROUTINE SURFACE_DRAG_B(rublten, rubltenb, rvblten, rvbltenb, u_phy, &
&  u_phyb, v_phy, v_phyb, xland, z, zb, ht, kpbl2d, ids, ide, jds, jde, &
&  kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&  jme, kms, kme, its, ite, jts, jte, kts, kte
  INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: kpbl2d
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: rublten, &
&  rvblten
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: rubltenb
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: u_phy, v_phy&
&  , z
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: u_phyb, v_phyb, zb
  REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: xland, ht
! Local
  REAL, DIMENSION(ims:ime) :: pwalls
  REAL :: v0, tao_xz, tao_yz, cd, zh, zwt
  REAL :: v0b, tao_xzb, tao_yzb, cdb, zhb, zwtb
  INTEGER :: i, j, i_start, i_end, i_endu, j_start, j_end, j_endv, k
  INTEGER :: branch
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: rvbltenb
  REAL :: tempb2
  REAL :: tempb1
  REAL :: tempb0
  REAL :: tempb
  REAL :: abs1
  REAL :: abs0
  REAL :: awalls,bwalls,cwalls
  LOGICAL :: xxwalls

! End declarations.
!-----------------------------------------------------------------------

  i_start = its

  IF (ite .GT. ide - 1) THEN
    i_end = ide - 1
  ELSE
    i_end = ite
  END IF

  i_endu = ite
  j_start = jts

  IF (jte .GT. jde - 1) THEN
    j_end = jde - 1
  ELSE
    j_end = jte
  END IF

  j_endv = jte

  DO j=j_start,j_endv
    DO i=i_start,i_end
      awalls=u_phy(i, kts, j)*u_phy(i, kts, j) +v_phy(i, kts, j)*v_phy(i, kts, j)
      v0 = SQRT(awalls)
      pwalls(i)= awalls
      bwalls=xland(i, j) - xland(i, j-1)
      IF (bwalls .GE. 0.) THEN
        abs1 = bwalls
      ELSE
        abs1 = -bwalls
      END IF
      xxwalls=.false.
      IF (abs1 .LT. 1.0e-10) THEN
        IF (xland(i, j) .LT. 1.5) THEN
          cd = 0.01
        ELSE
          cd = 0.001
          IF (cd .LT. 1.e-4*v0) THEN
            cd = 1.e-4*v0
            xxwalls=.true.
          END IF
          IF (cd .GT. 0.003) THEN
            cd = 0.003
            xxwalls=.false.
          END IF
        END IF
      ELSE
        cd = 0.003
      END IF

      tao_yz = cd*v0*v_phy(i, kts, j)/1000000.
      tao_yzb = 0.

      DO k=kts,kte
        zh = z(i, k, j) - ht(i, j)
        IF (zh .LT. 1000.) THEN
          tao_yzb = tao_yzb - (1000.-zh)*rvbltenb(i, k, j)/1000000.
          zb(i, k, j) = zb(i, k, j) + tao_yz*rvbltenb(i, k, j)
        END IF
      END DO

      tempb2 = v_phy(i, kts, j)*tao_yzb
      v_phyb(i, kts, j) = v_phyb(i, kts, j) + cd*v0*tao_yzb

      IF (awalls .NE. 0.) THEN
        IF (xxwalls) THEN
          v0b = (cd+ 1.e-4*v0)*tempb2/v0
        ELSE
          v0b = cd*tempb2/v0
        END IF
        u_phyb(i, kts, j) = u_phyb(i, kts, j) + u_phy(i, kts, j)*v0b
        v_phyb(i, kts, j) = v_phyb(i, kts, j) + v_phy(i, kts, j)*v0b
      END IF
    END DO

    DO i=i_start,i_endu
      v0 = SQRT(pwalls(i))
      bwalls =xland(i, j) - xland(i-1, j)
      IF (bwalls .GE. 0.) THEN
        abs0 = bwalls
      ELSE
        abs0 = -bwalls
      END IF
      xxwalls=.false.
      IF (abs0 .LT. 1.0e-10) THEN
        IF (xland(i, j) .LT. 1.5) THEN
          cd = 0.01
        ELSE
          cd = 0.001
          IF (cd .LT. 1.e-4*v0) THEN
            cd = 1.e-4*v0
            xxwalls=.true.
          END IF
          IF (cd .GT. 0.003) THEN
            cd = 0.003
            xxwalls=.false.
          END IF
        END IF
      ELSE
        cd = 0.003
      END IF

      tao_xzb = 0.
      tao_xz = cd*v0*u_phy(i, kts, j)/1000000.

      DO k=kts,kte
        zh = z(i, k, j) - ht(i, j)
        IF (zh .LT. 1000.) THEN
          tao_xzb = tao_xzb - rubltenb(i, k, j)*(1000.-zh)/1000000.
          zb(i, k, j) = zb(i, k, j) +tao_xz*rubltenb(i, k, j)
        END IF
      END DO

      tempb0 = u_phy(i, kts, j)*tao_xzb
      u_phyb(i, kts, j) = u_phyb(i, kts, j) + cd*v0*tao_xzb

      IF (pwalls(i).NE. 0.) THEN
        IF(xxwalls) THEN
          v0b = (cd+1.e-4*v0)*tempb0/v0
        ELSE
          v0b = cd*tempb0/v0
        END IF
        u_phyb(i, kts, j) = u_phyb(i, kts, j) + u_phy(i, kts, j)*v0b
        v_phyb(i, kts, j) = v_phyb(i, kts, j) + v_phy(i, kts, j)*v0b
      END IF
    END DO
  END DO

END SUBROUTINE SURFACE_DRAG_B

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4343) - 10 Feb 2012 10:52
!
!  Differentiation of surface_drag_init in reverse (adjoint) mode:
!   gradient     of useful results: rublten rqvblten rvblten rthblten
!   with respect to varying inputs: rublten rqvblten rvblten rthblten
SUBROUTINE SURFACE_DRAG_INIT_B(rublten, rubltenb, rvblten, rvbltenb, &
&  rthblten, rthbltenb, rqvblten, rqvbltenb, restart, ids, ide, jds, jde&
&  , kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte&
&)
  IMPLICIT NONE
!-------------------------------------------------------------------
  LOGICAL, INTENT(IN) :: restart
  INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&  jme, kms, kme, its, ite, jts, jte, kts, kte
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: rublten, rvblten, &
&  rthblten, rqvblten
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: rubltenb, rvbltenb, &
&  rthbltenb, rqvbltenb
  INTEGER :: i, j, k, itf, jtf, ktf
  INTRINSIC MIN0

  IF (jte .GT. jde - 1) THEN
    jtf = jde - 1
  ELSE
    jtf = jte
  END IF

  IF (kte .GT. kde - 1) THEN
    ktf = kde - 1
  ELSE
    ktf = kte
  END IF

  IF (ite .GT. ide - 1) THEN
    itf = ide - 1
  ELSE
    itf = ite
  END IF

  IF (.NOT.restart) THEN
    DO j=jtf,jts,-1
      DO k=ktf,kts,-1
        DO i=itf,its,-1
          rqvbltenb(i, k, j) = 0.0
          rthbltenb(i, k, j) = 0.0
          rvbltenb(i, k, j) = 0.0
          rubltenb(i, k, j) = 0.0
        END DO
      END DO
    END DO
  END IF

END SUBROUTINE SURFACE_DRAG_INIT_B

END MODULE a_module_bl_surface_drag
