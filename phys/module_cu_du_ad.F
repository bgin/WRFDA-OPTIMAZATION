!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
!
!  Differentiation of ducu in reverse (adjoint) mode (with options r8):
!   gradient     of useful results: th raincv t rthcuten pcps qv
!                z pratec rqvcuten rho dz8w
!   with respect to varying inputs: th raincv t rthcuten pcps qv
!                z pratec rqvcuten rho dz8w
MODULE a_module_cu_du
   USE module_wrf_error
  REAL    , PARAMETER :: cincap = -10.
  REAL    , PARAMETER :: capemin = 10.
  REAL    , PARAMETER :: dpthmin = 1000.
  REAL    , PARAMETER :: alpha = 0.00002
!--------------------------------------------------------------------
CONTAINS
SUBROUTINE DUCU_B(ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms&
&  , kme, its, ite, jts, jte, kts, kte, dt, ktau, dx, rho, rhob, raincv, &
&  raincvb, nca, pratec, pratecb, u, v, th, thb, t, tb, w, dz8w, dz8wb, z&
&  , zb, pcps, pcpsb, pi, w0avg, cp, rd, rv, g, xlv, ep2, svp1, svp2, &
&  svp3, svpt0, stepcu, cu_act_flag, warm_rain, cutop, cubot, qv, qvb, &
&  rthcuten, rthcutenb, rqvcuten, rqvcutenb)
  IMPLICIT NONE
!
!-------------------------------------------------------------
  INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&  jme, kms, kme, its, ite, jts, jte, kts, kte
  INTEGER, INTENT(IN) :: stepcu
  LOGICAL, INTENT(IN) :: warm_rain
  REAL, INTENT(IN) :: xlv
  REAL, INTENT(IN) :: cp, rd, rv, g, ep2
  REAL, INTENT(IN) :: svp1, svp2, svp3, svpt0
  INTEGER, INTENT(IN) :: ktau
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: u, v, w, th&
&  , t, qv, dz8w, z, pcps, rho, pi
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: thb, tb, qvb, dz8wb, zb&
&  , pcpsb, rhob
!
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: w0avg
  REAL, INTENT(IN) :: dt, dx
!
  REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: raincv, pratec
  REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: raincvb
  REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: nca
  REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: cubot, cutop
  LOGICAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: cu_act_flag
!
! Optional arguments
!
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) ::&
&  rthcuten, rqvcuten
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL :: rthcutenb, &
&  rqvcutenb
!
! LOCAL VARS
  LOGICAL :: flag_qr, flag_qi, flag_qs
  REAL, DIMENSION(kts:kte) :: u1d, v1d, t1d, th1d, dz1d, z1d, qv1d, p1d&
&  , rho1d, w0avg1d
  REAL, DIMENSION(kts:kte) :: t1db, th1db, dz1db, z1db, qv1db, p1db, &
&  rho1db
  REAL, DIMENSION(kts:kte) :: dqvdt, dthdt
  REAL, DIMENSION(kts:kte) :: dqvdtb, dthdtb
  REAL :: pprate, tst, tv, prs, rhoe, w0, scr1, dxsq, rthcumax
  REAL :: pprateb
  INTEGER :: i, j, k, i_start, i_end, j_start, j_end, sz, ntst, icldck
  INTEGER :: branch
  REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: pratecb

  ntst = stepcu
  icldck = MOD(ktau, ntst)
  IF (icldck .EQ. 0 .OR. ktau .EQ. 1) THEN

! Keep away from specified and relaxation zone (should be for just specified and nested bc)

  sz = 1
  i_start=max(ids+sz,its)
  i_end=min(ide-1-sz,ite)
  j_start=max(jds+sz,jts)
  j_end=min(jde-1-sz,jte)

  qv1db = 0.
  th1db = 0.
  rho1db = 0.
  dz1db = 0.
  t1db = 0.

    DO j=j_end,j_start,-1
      DO i=i_end,i_start,-1
        IF (PRESENT(rthcuten) .AND. PRESENT(rqvcuten)) THEN
          pprateb = pratecb(i, j) + dt*raincvb(i, j)
          raincvb(i,j) = 0.
          pratecb(i,j) = 0.
          dqvdtb(kts:kte) = rqvcutenb(i,kts:kte,j)
          dthdtb(kts:kte) = rthcutenb(i,kts:kte,j)
        ELSE
          pprateb = 0.
        END IF

        DO K=kts,kte
          IF(QV(I,K,J).LT.1.E-08) THEN
            QV1D(K) = 1.E-08
          ELSE
            QV1D(K)=QV(I,K,J)
          END IF
        ENDDO

        T1D(kts:kte) =T(I,kts:kte,J)
        TH1D(kts:kte) =TH(I,kts:kte,J)
        RHO1D(kts:kte) =rho(I,kts:kte,J)

        P1D(kts:kte) =Pcps(I,kts:kte,J)
        DZ1D(kts:kte)=dz8w(I,kts:kte,J)
        Z1D(kts:kte) =z(I,kts:kte,J)

        CALL DUCU1D_B(i, j, u1d, v1d, t1d, t1db, qv1d, qv1db, p1d, p1db&
&                , dz1d, dz1db, z1d, z1db, w0avg1d, dt, dx, dxsq, rho1d, &
&                rho1db, th1d, th1db, xlv, cp, rd, rv, g, ep2, svp1, svp2&
&                , svp3, svpt0, dqvdt, dqvdtb, dthdt, dthdtb, pprate, &
&                pprateb, nca, ntst, cutop, cubot, ids, ide, jds, jde, &
&                kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, &
&                jte, kts, kte)

        DO k=kts,kte
          IF(QV(I,K,J).GE.1.e-08) qvb(i,k,j) = qvb(i,k,j) +qv1db(k)
        END DO

        zb(i, kts:kte, j) = zb(i, kts:kte, j) + z1db(kts:kte)
        dz8wb(i, kts:kte, j) = dz8wb(i, kts:kte, j) + dz1db(kts:kte)
        pcpsb(i, kts:kte, j) = pcpsb(i, kts:kte, j) + p1db(kts:kte)
        rhob(i, kts:kte, j) = rhob(i, kts:kte, j) + rho1db(kts:kte)
        thb(i, kts:kte, j) = thb(i, kts:kte, j) + th1db(kts:kte)
        tb(i, kts:kte, j) = tb(i, kts:kte, j) + t1db(kts:kte)

        dz1db(kts:kte) = 0.
        qv1db(kts:kte) = 0.
        rho1db(kts:kte) = 0.
        th1db(kts:kte) = 0.
        t1db(kts:kte) = 0.

        pratecb(i,j) = 0.
        raincvb(i,j) = 0.
      END DO
    END DO

    rqvcutenb(i_start:i_end,kts:kte,j_start:j_end) = 0.
    rthcutenb(i_start:i_end,kts:kte,j_start:j_end) = 0.
  END IF

END SUBROUTINE DUCU_B

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
!
!  Differentiation of ducu1d in reverse (adjoint) mode (with options r8):
!   gradient     of useful results: dthdt p0 z t0 th0 pprate rhoe
!                dzq dqvdt qv0
!   with respect to varying inputs: dthdt p0 z t0 th0 rhoe dzq
!                dqvdt qv0
! ****************************************************************************
!-----------------------------------------------------------
SUBROUTINE DUCU1D_B(i, j, u0, v0, t0, t0b, qv0, qv0b, p0, p0b, dzq, dzqb&
&  , z, zb0, w0avg1d, delt, dx, dxsq, rhoe, rhoeb, th0, th0b, xlv, cp, rd&
&  , rv, g, ep2, svp1, svp2, svp3, svpt0, dqvdt, dqvdtb, dthdt, dthdtb, &
&  pprate, pprateb, nca, ntst, cutop, cubot, ids, ide, jds, jde, kds, kde&
&  , ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte)
  IMPLICIT NONE
!-----------------------------------------------------------------------
!-----------------------------------------------------------
  INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&  jme, kms, kme, its, ite, jts, jte, kts, kte, i, j, ntst
!
  REAL, DIMENSION(kts:kte), INTENT(IN) :: u0, v0, t0, th0, qv0, p0, rhoe&
&  , dzq, z, w0avg1d
  REAL, DIMENSION(kts:kte) :: t0b, th0b, qv0b, p0b, rhoeb, dzqb, zb0
!
  REAL, INTENT(IN) :: delt, dx, dxsq
!
  REAL, INTENT(IN) :: xlv, cp, rd, rv, g
  REAL, INTENT(IN) :: ep2, svp1, svp2, svp3, svpt0
!
  REAL, DIMENSION(kts:kte), INTENT(INOUT) :: dqvdt, dthdt
  REAL, DIMENSION(kts:kte), INTENT(INOUT) :: dqvdtb
  REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: nca
  REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: cubot, cutop
  REAL :: pprate
  REAL :: pprateb
!
!...DEFINE LOCAL VARIABLES...
!
  REAL, DIMENSION(kts:kte) :: cond, h, hs, qs, x
  REAL, DIMENSION(kts:kte) :: condb, hb, hsb, qsb, xb
  REAL :: buoy, cape, cin, dh, dq, dt, dtm, es, evap, hp, mp, qp, &
&  qsp, rrk, rrkp, tdp, zb, zg, zi, zt
  REAL :: dqb, dtb, evapb, hpb, mpb, qpb, qspb, rrkb, rrkpb
  INTEGER :: ipos, isat, k, kb, ki, kt
  INTEGER :: branch,branch1,branch2
  INTEGER :: ad_count
  INTEGER :: i0
  INTEGER :: ad_from
  INTEGER :: ad_to
  INTEGER :: ad_from0
  REAL, DIMENSION(kts:kte), INTENT(INOUT) :: dthdtb
  REAL :: temp3
  REAL :: temp2
  REAL :: temp1
  REAL :: temp0
  REAL :: temp7b
  REAL :: temp9b0
  REAL :: temp6b
  REAL :: temp12
  REAL :: temp10
  REAL :: temp9b
  REAL :: temp5b0
  REAL :: tempb
  REAL :: temp2b
  REAL :: temp5b
  REAL :: temp8b0
  REAL :: temp8b
  REAL :: abs1
  REAL :: abs0
  REAL :: temp1b
  REAL :: temp
  REAL :: temp6b0
  REAL :: temp9
  REAL :: temp8
  REAL :: temp1b0
  REAL :: temp7
  REAL :: temp10b
  REAL :: temp6
  REAL :: temp4b
  REAL :: temp5
  REAL :: temp10b0
  REAL :: temp4
  REAL, DIMENSION(kts:kte,kts:kte) :: ppwalls,qqwalls,eewalls
  LOGICAL, DIMENSION(kts:kte,kts:kte) :: wallstdp
  REAL, DIMENSION(kts:kte) :: pwalls
  REAL :: gwalls,cwalls,awalls,bwalls,dwalls,ewalls
  REAL :: t0kt,th0kt,xkt,dzqkt,qskt,qv0kt,rhoekt,hskt
  LOGICAL, DIMENSION(kts:kte,kts:kte) :: llwalls

  CALL HOPLOGICARRAY(wallstdp,(kme-kms+1)*(kme-kms+1))

  DO k=kts,kte
    h(k) = cp*t0(k) + g*z(k) + xlv*qv0(k)
    pwalls(k)=1000.*svp1*EXP(svp2*(t0(k)-svpt0)/(t0(k)-svp3))
    qs(k) = ep2*pwalls(k)/(p0(k)-pwalls(k))
    hs(k) = cp*t0(k) + g*z(k) + xlv*qs(k)
    x(k) = xlv*xlv*qs(k)/(cp*rv*t0(k)*t0(k))
  END DO
!
!...LOOP OVER PARCELS
loop_origin:DO ki=kts,kte
    hp = h(ki)
    qp = qv0(ki)
    mp = alpha*rhoe(ki)*dzq(ki)
    buoy = 0.
    cape = 0.
    dtm = 0.
    isat = 0
    ipos = 0
    CALL PUSHINTEGER4(kt)
    kt = 0
    kb = 0
    zt = 0.
    zb = 0.
    cond = 0.
    CALL PUSHINTEGER4(k)
    ad_count = 1
    awalls=t0(ki) + g/cp*z(ki)
!
!...LIFT PARCEL
loop_lift:DO k=ki+1,kte
      IF (wallstdp(k,ki)) THEN
        dt = awalls -g/cp*z(k) - t0(k)
        cond(k) = 0.
      ELSE
        IF (isat .EQ. 0) THEN
          kb = k
          zb = z(k) - 0.5*dzq(k)
        END IF
        isat = 1
        dh = (hp - hs(k))/(1.+x(k))
        dt = dh/cp
        qsp = qs(k) + dh*x(k)/xlv
        gwalls=qp-qsp
        cond(k) = mp*gwalls
        ppwalls(k,ki) =gwalls
        qp = qsp
      END IF

      buoy = buoy + g*dt*dzq(k)/t0(k)
      cape=max(cape,buoy)

      IF(dt .GE. 0.)THEN
        kt=k
        zt=z(k)+0.5*dzq(k)
      ELSE IF(dt .LT. 0. .AND. dtm .GE. 0.)THEN
        IF(abs(dt) .LT. abs(dtm))THEN
          kt=k
          zt=z(k)+0.5*dzq(k)
        ENDIF
      ENDIF

      dtm = dt

      IF (buoy .LT. cincap) THEN
        GOTO 100
      ELSE
        IF (buoy .GT. 0.) ipos = 1
        IF (k .EQ. 1) THEN
          kt = k
          zt = z(k) + 0.5*dzq(k)
        END IF
        CALL PUSHINTEGER4(k)
        ad_count = ad_count + 1
      END IF
    END DO loop_lift

    CALL PUSHCONTROL1B(0)
    CALL PUSHINTEGER4(ad_count)
    GOTO 110
100 CALL PUSHCONTROL1B(1)
    CALL PUSHINTEGER4(ad_count)

110 IF (isat .EQ. 0) THEN
      CALL PUSHCONTROL3B(3)
    ELSE IF (zt - zb .LE. dpthmin) THEN
      CALL PUSHCONTROL3B(2)
    ELSE IF (ipos .EQ. 0) THEN
      CALL PUSHCONTROL3B(1)
    ELSE IF (cape .LE. capemin) THEN
      CALL PUSHCONTROL3B(0)
    ELSE

      ad_from = kt - 1
      CALL PUSHINTEGER4(k)

      k = ki-1
      CALL PUSHINTEGER4(k + 1)
      CALL PUSHINTEGER4(ad_from)

      rrkp = 0.
      ad_from0 = kt

loop_rainfall:DO k=ad_from0,1,-1
        rrk = rrkp + cond(k)

        IF (k .GE. kb) THEN
          evap = 0.
        ELSE
          evap = dzq(k)*rrkp*0.1*(qs(k)-qv0(k))
          qqwalls(k,ki) =rrkp
        END IF

        IF (rrk .GT. evap) THEN
          llwalls(k,ki) =.false.
        ELSE
          evap = rrk
          llwalls(k,ki) =.true.
        END IF

        IF (evap.ne.0.) THEN
          rrkp = rrk - evap
        ELSE
          rrkp = rrk
        END IF
        eewalls(k,ki) =evap
      END DO loop_rainfall

      CALL PUSHINTEGER4(ad_from0)
      CALL PUSHINTEGER4(kb)
      CALL PUSHCONTROL3B(4)
    END IF
  END DO loop_origin

  qsb = 0.
  xb = 0.
  hsb = 0.

  DO ki=kte,kts,-1
    CALL POPCONTROL3B(branch)
    IF (branch .NE. 4) THEN
      hpb = 0.
      condb = 0.
      mpb = 0.
    ELSE
      t0kt =t0(kt)
      th0kt =th0(kt)
      xkt=x(kt)
      dzqkt=dzq(kt)
      qv0kt=qv0(kt)
      qskt=qs(kt)
      rhoekt=rhoe(kt)
      hskt =hs(kt)

      rrkpb = pprateb
      condb(ad_from0+1:kte) = 0.
      bwalls =cp*t0kt
      gwalls =xlv/bwalls
      CALL POPINTEGER4(kb)
      CALL POPINTEGER4(ad_from0)
      DO k=1,ad_from0,1
        evap =eewalls(k,ki)
        IF (evap.ne.0.) THEN
          temp9 = rhoe(k)*dzq(k)
          temp10 = bwalls*temp9
          temp10b = -xlv*dthdtb(k)/temp10
          temp10b0 = -th0kt*evap*temp10b/temp10
          dwalls =dqvdtb(k)/temp9
          ewalls =bwalls*temp10b0 -evap*dwalls/temp9
          th0b(kt) = th0b(kt) + evap*temp10b

          IF (llwalls(k,ki).OR.(k.LT.kb)) THEN
          evapb = dwalls - rrkpb+ th0kt*temp10b
          END IF

          t0b(kt) = t0b(kt) + temp9*cp*temp10b0
          rhoeb(k) = rhoeb(k) + dzq(k)*ewalls
          dzqb(k) = dzqb(k)  + rhoe(k)*ewalls
        ELSE 
          IF (llwalls(k,ki).OR.(k.LT.kb)) THEN
            temp9 = rhoe(k)*dzq(k)
            temp10b = -gwalls*dthdtb(k)/temp9
            evapb = dqvdtb(k)/temp9 - rrkpb+ th0kt*temp10b
          END IF
        END IF

        IF (llwalls(k,ki)) THEN
          rrkb = rrkpb + evapb
          evapb = 0.
        ELSE
          rrkb = rrkpb
        END IF

        IF (k .GE. kb) THEN
          evapb = 0.
          rrkpb = rrkb
        ELSE
          IF(evapb.EQ.0.) THEN 
            rrkpb = rrkb
          ELSE
            temp9b = dzq(k)*qqwalls(k,ki)*0.1*evapb
            temp9b0 = (qs(k)-qv0(k))*0.1*evapb
            qsb(k) = qsb(k) + temp9b
            qv0b(k) = qv0b(k) - temp9b
            dzqb(k) = dzqb(k) + qqwalls(k,ki)*temp9b0
            rrkpb = rrkb + dzq(k)*temp9b0
          END IF
        END IF

        condb(k) = rrkb
      END DO

      mp = alpha*rhoe(ki)*dzq(ki)
      mpb = 0.
      CALL POPINTEGER4(ad_from)
      CALL POPINTEGER4(ad_to)

      DO k=ad_to,ad_from,1
        temp7 = rhoe(k)*dzq(k)
        temp7b = dthdtb(k)/temp7
        temp8b = dqvdtb(k)/temp7
        gwalls= (th0(k+1)-th0(k))*temp7b +(qv0(k+1)-qv0(k))*temp8b
        mpb = mpb + gwalls
        temp8b0 = -mp*gwalls/temp7
        qv0b(k+1) = qv0b(k+1) + mp*temp8b
        qv0b(k) = qv0b(k) - mp*temp8b
        rhoeb(k) = rhoeb(k) + dzq(k)*temp8b0
        dzqb(k) = dzqb(k) + rhoe(k)*temp8b0
        th0b(k+1) = th0b(k+1) + mp*temp7b
        th0b(k) = th0b(k) - mp*temp7b
      END DO

      CALL POPINTEGER4(k)

      temp3 = cp*(xkt+1.)
      temp5 = t0kt*rhoekt
      temp5b = dthdtb(kt)/(temp5*dzqkt)
      hp = h(ki)
      dh = hp - hskt
      dq = qskt + dh/xlv*xkt/(1.+xkt) - qv0kt
      temp6 = rhoekt*dzqkt
      temp6b = dqvdtb(kt)/temp6
      temp6b0 = -mp*dq*temp6b/temp6
      dqb = mp*temp6b
      dt = dh/cp/(1.+xkt)
      mpb = mpb + th0kt*dt*temp5b + dq*temp6b
      temp5b0 = -th0kt*mp*dt*temp5b/(temp5*dzqkt)
      rhoeb(kt) = rhoeb(kt) + dzqkt*(t0kt*temp5b0 + temp6b0)
      dzqb(kt) = dzqb(kt) + temp5*temp5b0 + rhoekt*temp6b0
      th0b(kt) = th0b(kt) + mp*dt*temp5b
      dtb = th0kt*mp*temp5b
      t0b(kt) = t0b(kt) + dzqkt*rhoekt*temp5b0
      temp4 = xlv*(xkt+1.)
      temp4b = dqb/temp4
      qsb(kt) = qsb(kt) + dqb
      hpb = dtb/temp3 + xkt*temp4b
      xb(kt) = xb(kt) + dh*((1.-xkt*xlv/temp4)*temp4b -cp*dtb/temp3/temp3)
      qv0b(kt) = qv0b(kt) - dqb
      hsb(kt) = hsb(kt) -hpb
    END IF

    CALL POPINTEGER4(ad_count)

    DO i0=1,ad_count
      IF (i0 .EQ. 1) THEN
        qpb = 0.
        CALL POPCONTROL1B(branch)
        IF (branch.EQ.0) GOTO 120
      END IF

      IF(.NOT.wallstdp(k,ki)) THEN
        IF(condb(k).EQ.0.) THEN
          temp2 = xlv*(x(k)+1.)
          temp2b = qpb/temp2
          qsb(k) = qsb(k) + qpb
          qpb = 0.
          gwalls = x(k)*temp2b
          xb(k) = xb(k) + (hp-hs(k))*(1.-x(k)*xlv/temp2)*temp2b
          hpb = hpb + gwalls
          hsb(k) = hsb(k) -gwalls
        ELSE
          qspb = qpb - mp*condb(k)
          mpb = mpb + ppwalls(k,ki)*condb(k)
          qpb = mp*condb(k)
          temp2 = xlv*(x(k)+1.)
          temp2b = qspb/temp2
          qsb(k) = qsb(k) + qspb
          gwalls = x(k)*temp2b
          xb(k) = xb(k) + (hp-hs(k))*(1.-x(k)*xlv/temp2)*temp2b
          hpb = hpb + gwalls
          hsb(k) = hsb(k) -gwalls
        END IF
      END IF
      condb(k) = 0.
 120  CALL POPINTEGER4(k)
    END DO

    CALL POPINTEGER4(kt)
    rhoeb(ki) = rhoeb(ki) + alpha*dzq(ki)*mpb
    dzqb(ki) = dzqb(ki) + alpha*rhoe(ki)*mpb
    qv0b(ki) = qv0b(ki) + qpb
    hb(ki) = hpb
  END DO

  dqvdtb(kts:kte) = 0.
  dthdtb(kts:kte) = 0.

  gwalls=xlv*xlv/(cp*rv)

!LPB01

  DO k=kte,kts,-1
    temp1b = gwalls*xb(k)/(t0(k)*t0(k))
    qsb(k) = qsb(k) + xlv*hsb(k) + temp1b
    zb0(k) = g*(hb(k) + hsb(k))
    temp1b0 = ep2*qsb(k)/(p0(k)-pwalls(k))
    p0b(k) = -pwalls(k)*temp1b0/(p0(k)-pwalls(k))
    temp0 = t0(k) - svp3
    tempb = svp2*pwalls(k)*(temp1b0- p0b(k))/temp0
    t0b(k) = t0b(k) + cp*(hsb(k)+hb(k)) + (1.0-(t0(k)-svpt0)/temp0)*tempb&
           -qs(k)*2.*temp1b/t0(k)
    qv0b(k) = qv0b(k) + xlv*hb(k)
  END DO

END SUBROUTINE DUCU1D_B

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4343) - 10 Feb 2012 10:52
!
!  Differentiation of ducuinit in reverse (adjoint) mode:
!   gradient     of useful results: rqccuten rthcuten w0avg rqvcuten
!   with respect to varying inputs: rqccuten rthcuten w0avg rqvcuten
SUBROUTINE DUCUINIT_B(rthcuten, rthcutenb, rqvcuten, rqvcutenb, rqccuten&
&  , rqccutenb, rqrcuten, rqicuten, rqscuten, nca, w0avg, w0avgb, p_qc, &
&  p_qr, svp1, svp2, svp3, svpt0, p_first_scalar, restart, &
&  allowed_to_read, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms&
&  , kme, its, ite, jts, jte, kts, kte)
  IMPLICIT NONE
!--------------------------------------------------------------------
  LOGICAL, INTENT(IN) :: restart, allowed_to_read
  INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&  jme, kms, kme, its, ite, jts, jte, kts, kte
  INTEGER, INTENT(IN) :: p_qc, p_qr, p_first_scalar
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: rthcuten, rqvcuten, &
&  rqccuten, rqrcuten, rqicuten, rqscuten
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: rthcutenb, rqvcutenb, &
&  rqccutenb
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: w0avg
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: w0avgb
  REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: nca
  INTEGER :: i, j, k, itf, jtf, ktf
  REAL, INTENT(IN) :: svp1, svp2, svp3, svpt0
  INTEGER :: branch
  INTRINSIC MIN0
  IF (jte .GT. jde - 1) THEN
    jtf = jde - 1
  ELSE
    jtf = jte
  END IF
  IF (kte .GT. kde - 1) THEN
    ktf = kde - 1
  ELSE
    ktf = kte
  END IF
  IF (ite .GT. ide - 1) THEN
    itf = ide - 1
  ELSE
    itf = ite
  END IF
  IF (.NOT.restart) THEN
    IF (p_qc .GE. p_first_scalar) THEN
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    DO j=jtf,jts,-1
      DO k=ktf,kts,-1
        DO i=itf,its,-1
          w0avgb(i, k, j) = 0.0
        END DO
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      DO j=jtf,jts,-1
        DO k=ktf,kts,-1
          DO i=itf,its,-1
            rqccutenb(i, k, j) = 0.0
          END DO
        END DO
      END DO
    END IF
    DO j=jtf,jts,-1
      DO k=ktf,kts,-1
        DO i=itf,its,-1
          rqvcutenb(i, k, j) = 0.0
          rthcutenb(i, k, j) = 0.0
        END DO
      END DO
    END DO
  END IF
END SUBROUTINE DUCUINIT_B

END MODULE a_module_cu_du
